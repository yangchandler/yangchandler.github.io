<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangchandler.github.io/"/>
  <updated>2020-07-19T12:21:05.797Z</updated>
  <id>https://yangchandler.github.io/</id>
  
  <author>
    <name>ChandlerYang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSAPP</title>
    <link href="https://yangchandler.github.io/2020/07/21/CSAPP/"/>
    <id>https://yangchandler.github.io/2020/07/21/CSAPP/</id>
    <published>2020-07-21T13:04:12.154Z</published>
    <updated>2020-07-19T12:21:05.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="6、存储器层次结构"><a href="#6、存储器层次结构" class="headerlink" title="6、存储器层次结构"></a>6、存储器层次结构</h3><p>​    1、存在SRAM,DRAM以及ROM等种类的存储器，SRAM一般作为L1，L2（大型计算机系统还会有L3级）级缓存，DRAM一般用作主存，RAM断电信息消失；ROM一般用于系统固件（开机启动光盘等），断电信息不丢失。</p><p>​    2、高速缓存存储器的组织结构分为直接映射（多组单行）、组相联（多组多行）和全相联（单组多行）；进行高速缓存与下一级存储级进行地址映射时，组索引对应于下一级地址的中间位索引，已满足局部性。</p><p>   3、直写：处理器会直接将高速缓存中的数据写入主内存。直至将数据存储至主内存，写入循环才能完成；</p><p>​         回写：处理器开始写入循环时，高速缓存将接收数据并停止循环。当系统总线可用时，缓存数据写入主存；</p><p>​        优劣：直写保证数据匹配，但是会降低性能；回写可以维持性能，因为其时在总线不塞车的情况下使用总线    4、将指令和数据缓存分开，可以确保数据访问与指令访问不会产生冲突；代价是容量不命中概率增加</p><p>​    5、 缓存越大，命中率越高、访存时间越长</p><p>​           块越大，空间局部性效果越好，缓存固定时，块越大则行越少，时间局部性变差</p><p>​            相连度E越大，抖动减少，命中率提高，难以实现高速访存</p><p>​            高速缓存读不命中开销不大，因为其不触发内存写。</p><p>​            越到低层次的存储结构，越可能采用回写方式。</p><p>​    6、冷不命中率是不可避免的</p><p>​    7、时间局部性效果很差时，空间局部性可以补救</p><p>​    8、SSD相比于SATA   读写快、防摔、体积小、功耗低</p><p>​                                        成本高、寿命短（SSD写要擦除整个块，擦除的次数是有限的，一般通过磁盘控制器将擦                                    除操作平均到整个硬盘）</p><h3 id="7、链接"><a href="#7、链接" class="headerlink" title="7、链接"></a>7、链接</h3><p>​    1、链接是将各种代码和数据片段收集并组合成一个单一文件的过程，可以发生在编译时（源代码翻译成机器代码时）、加载时（机器代码进入内存时）、运行时（程序执行时）。</p><p>​    2、每个可重定位目标模块m都有一个符号表，定义可被其他模块引用的符号、定义引用其他模块的符号，定义不可被其他模块引用的符合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;6、存储器层次结构&quot;&gt;&lt;a href=&quot;#6、存储器层次结构&quot; class=&quot;headerlink&quot; title=&quot;6、存储器层次结构&quot;&gt;&lt;/a&gt;6、存储器层次结构&lt;/h3&gt;&lt;p&gt;​    1、存在SRAM,DRAM以及ROM等种类的存储器，SRAM一般作为L1，
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://yangchandler.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>牛客网剑指Offer</title>
    <link href="https://yangchandler.github.io/2020/07/21/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%89%91%E6%8C%87Offer/"/>
    <id>https://yangchandler.github.io/2020/07/21/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%89%91%E6%8C%87Offer/</id>
    <published>2020-07-21T13:04:12.154Z</published>
    <updated>2020-06-30T05:51:57.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="牛客网剑指Offer"><a href="#牛客网剑指Offer" class="headerlink" title="牛客网剑指Offer"></a>牛客网剑指Offer</h1><p>面试51</p><p>23</p><p>leetcode 滑动数组中的中值</p><p>牛客   二叉树 序列化</p><p>1.声明指针时给指针赋值为空</p><table><thead><tr><th align="center">Date</th><th align="center">num</th></tr></thead><tbody><tr><td align="center">2020.06.19</td><td align="center">8</td></tr><tr><td align="center">2020.06.20</td><td align="center">12</td></tr><tr><td align="center">2020.06.21</td><td align="center">3</td></tr><tr><td align="center">2020.06.22</td><td align="center">3</td></tr><tr><td align="center">2020.06.23</td><td align="center">2</td></tr><tr><td align="center">2020.06.26</td><td align="center">1</td></tr><tr><td align="center">2020.06.27</td><td align="center">5</td></tr><tr><td align="center">2020.06.28</td><td align="center">5</td></tr><tr><td align="center">2020.06.29</td><td align="center">9</td></tr><tr><td align="center">2020.06.30</td><td align="center">3   //51</td></tr></tbody></table><h4 id="1、二维数组中的查找"><a href="#1、二维数组中的查找" class="headerlink" title="1、二维数组中的查找"></a>1、二维数组中的查找</h4><p>思路：二分查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=<span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> col=<span class="built_in">array</span>[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=row<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j&lt; col)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3、从尾到头打印链表"><a href="#3、从尾到头打印链表" class="headerlink" title="3、从尾到头打印链表"></a>3、从尾到头打印链表</h4><p>思路： insert</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            res.insert(res.<span class="built_in">begin</span>(),head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4、重建二叉树"><a href="#4、重建二叉树" class="headerlink" title="4、重建二叉树"></a>4、重建二叉树</h4><p>​    确定中序序列索引号的时候可以使用unordered_map 来提高速度</p><p>递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">make</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pb,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pe,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vb,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ve)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vb==ve) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* temp=<span class="keyword">new</span> TreeNode(*pb);</span><br><span class="line">        <span class="keyword">auto</span> iter=<span class="built_in">find</span>(vb,ve,*pb);</span><br><span class="line">        temp-&gt;left=make(pb+<span class="number">1</span>,pb+<span class="number">1</span>+(iter-vb),vb,iter);</span><br><span class="line">        temp-&gt;right=make(pb+<span class="number">1</span>+(iter-vb),pe,iter+<span class="number">1</span>,ve);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> make(pre.<span class="built_in">begin</span>(),pre.<span class="built_in">end</span>(),vin.<span class="built_in">begin</span>(),vin.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6、旋转数组中的最小数字"><a href="#6、旋转数组中的最小数字" class="headerlink" title="6、旋转数组中的最小数字"></a>6、旋转数组中的最小数字</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=A.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">int</span> m=(i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[m] &gt; A[j]) i=m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (A[m]&lt; A[j]) j=m;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="12、数值的整数次方"><a href="#12、数值的整数次方" class="headerlink" title="12、数值的整数次方"></a>12、数值的整数次方</h4><p>思路： Power(2,5)   5=101   base对应当前位的base的次方，r为当前位为1时相乘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> e=<span class="built_in">abs</span>(exponent);</span><br><span class="line">        <span class="keyword">double</span> r=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e &amp; <span class="number">1</span>) r*=base;</span><br><span class="line">            base*=base;</span><br><span class="line">            e&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (exponent &gt; <span class="number">0</span>) ? r:<span class="number">1</span>/r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="13、调整数组顺序使奇数位于偶数之前"><a href="#13、调整数组顺序使奇数位于偶数之前" class="headerlink" title="13、调整数组顺序使奇数位于偶数之前"></a>13、调整数组顺序使奇数位于偶数之前</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录从左到右开始的奇数位置；</span></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp=<span class="built_in">array</span>;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> odd_index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i] % <span class="number">2</span> == <span class="number">1</span>) <span class="built_in">array</span>[odd_index++]=temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i] % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">array</span>[odd_index++]=temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="16、合并两个排序链表"><a href="#16、合并两个排序链表" class="headerlink" title="16、合并两个排序链表"></a>16、合并两个排序链表</h4><p>思路：就指针比大小后移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* res=<span class="keyword">new</span> ListNode(<span class="number">0</span>),*temp=res;;</span><br><span class="line">        <span class="keyword">while</span>(pHead1 &amp;&amp; pHead2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val &lt;= pHead2-&gt;val)&#123;</span><br><span class="line">                res-&gt;next=pHead1;</span><br><span class="line">                pHead1=pHead1-&gt;next;               </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res-&gt;next=pHead2;</span><br><span class="line">                pHead2=pHead2-&gt;next;  </span><br><span class="line">            &#125;</span><br><span class="line">            res=res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        res-&gt;next=  pHead1==<span class="literal">NULL</span> ? pHead2:pHead1;</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="17、树的子结构"><a href="#17、树的子结构" class="headerlink" title="17、树的子结构"></a>17、树的子结构</h4><p>思路： 直接递归比就完事</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* p1,TreeNode* p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p1 || p1-&gt;val != p2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(p1-&gt;left, p2-&gt;left) &amp;&amp; check(p1-&gt;right, p2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (pRoot1 !=<span class="literal">NULL</span> &amp;&amp; pRoot2 !=<span class="literal">NULL</span>) &amp;&amp;(check(pRoot1,pRoot2) ||check(pRoot1-&gt;left,pRoot2) ||check(pRoot1-&gt;right,pRoot2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="19、顺时针打印矩阵"><a href="#19、顺时针打印矩阵" class="headerlink" title="19、顺时针打印矩阵"></a>19、顺时针打印矩阵</h4><p>思路：控制好边界判定即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=col<span class="number">-1</span>,top=<span class="number">0</span>,btm=row<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right &amp;&amp; top&lt;=btm)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++) res.push_back(matrix[top][i]);</span><br><span class="line">            <span class="keyword">if</span>(top &lt; btm)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=top+<span class="number">1</span>;i&lt;=btm;i++) res.push_back(matrix[i][right]);</span><br><span class="line">                <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=right<span class="number">-1</span>;i&gt;=left;i--) res.push_back(matrix[btm][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top+<span class="number">1</span> &lt; btm &amp;&amp; left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=btm<span class="number">-1</span>;i&gt;=top+<span class="number">1</span>;i--) res.push_back(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;right--;top++;btm--; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="20、包含min函数的栈"><a href="#20、包含min函数的栈" class="headerlink" title="20、包含min函数的栈"></a>20、包含min函数的栈</h4><p>思路:利用辅助栈存储当前数据栈中的较小元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; curm;</span><br><span class="line">    <span class="keyword">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">        <span class="keyword">if</span>(curm.empty() || value&lt;=curm.top())&#123;</span><br><span class="line">            curm.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.top()==curm.top()) curm.pop();</span><br><span class="line">        data.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curm.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="22、从上往下打印二叉树"><a href="#22、从上往下打印二叉树" class="headerlink" title="22、从上往下打印二叉树"></a>22、从上往下打印二叉树</h4><p>同60题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class="line">        qu.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len=qu.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp=qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                res.push_back(temp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left) qu.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right) qu.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="23、二叉树的后续遍历"><a href="#23、二叉树的后续遍历" class="headerlink" title="23、二叉树的后续遍历"></a>23、二叉树的后续遍历</h4><p>思路：递归判断子树是不是 二叉搜索树即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!postorder.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> recur(postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p=i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p]&lt;postorder[j]) p++;</span><br><span class="line">        <span class="keyword">int</span> m=p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p]&gt;postorder[j]) p++;</span><br><span class="line">        <span class="keyword">return</span> p==j &amp;&amp; recur(postorder,i,m<span class="number">-1</span>) &amp;&amp;recur(postorder,m,j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="24、二叉树中和为某一值的路径"><a href="#24、二叉树中和为某一值的路径" class="headerlink" title="24、二叉树中和为某一值的路径"></a>24、二叉树中和为某一值的路径</h4><p>思路：先序遍历，递归   和为 0 时压入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(TreeNode* root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        val-=root-&gt;val;</span><br><span class="line">        temp.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(val==<span class="number">0</span> &amp;&amp; !root-&gt;left &amp;&amp;!root-&gt;right) res.push_back(temp);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) pre_order(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) pre_order(root-&gt;right, val);</span><br><span class="line">        temp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">FindPath</span><span class="params">(TreeNode* root,<span class="keyword">int</span> expectNumber)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        pre_order(root, expectNumber);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="25、复杂链表的复制"><a href="#25、复杂链表的复制" class="headerlink" title="25、复杂链表的复制"></a>25、复杂链表的复制</h4><p>思路：第一步：在原有链表中 每一个节点都插入一个与当前节点相同值的节点</p><p>​            第二步： temp-&gt;next-&gt;random=temp-&gt;random-&gt;next 将random链接起来</p><p>​            第三步： 拆分链表 返回结果指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        RandomListNode* temp=pHead;</span><br><span class="line">        <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">            RandomListNode* cur=<span class="keyword">new</span> RandomListNode(temp-&gt;label);</span><br><span class="line">            cur-&gt;next=temp-&gt;next;</span><br><span class="line">            temp-&gt;next=cur;</span><br><span class="line">            temp=temp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=pHead;</span><br><span class="line">        <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;<span class="built_in">random</span>) temp-&gt;next-&gt;<span class="built_in">random</span>=temp-&gt;<span class="built_in">random</span>-&gt;next;</span><br><span class="line">            temp=temp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=pHead;</span><br><span class="line">        RandomListNode* res=pHead-&gt;next,*cur=res;</span><br><span class="line">        <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">            temp-&gt;next=cur-&gt;next;</span><br><span class="line">            temp=temp-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(temp)&#123;</span><br><span class="line">                cur-&gt;next=temp-&gt;next;</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="26、二叉搜索树与双向链表"><a href="#26、二叉搜索树与双向链表" class="headerlink" title="26、二叉搜索树与双向链表"></a>26、二叉搜索树与双向链表</h4><p>思路：采取中序遍历的方式；并存储前方节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    TreeNode* head=<span class="literal">NULL</span>,*pre=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre) &#123;</span><br><span class="line">            pre-&gt;right=root;</span><br><span class="line">            root-&gt;left=pre;</span><br><span class="line">            pre=root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            head=root;</span><br><span class="line">            pre=root;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root ) <span class="keyword">return</span> root;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="27、字符串的排列"><a href="#27、字符串的排列" class="headerlink" title="27、字符串的排列"></a>27、字符串的排列</h4><p>思路：set查重 + 全排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span> str,<span class="keyword">int</span> k, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==m) &#123;</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.count(str[i])) <span class="keyword">continue</span>;</span><br><span class="line">            st.insert(str[i]);</span><br><span class="line">            swap(str[i],str[k]);</span><br><span class="line">            Permutation(str,k+<span class="number">1</span>,m);</span><br><span class="line">            swap(str[i],str[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=str.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        Permutation(str,<span class="number">0</span>,m);</span><br><span class="line">        sort(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="28、数组中出现超过一半的数"><a href="#28、数组中出现超过一半的数" class="headerlink" title="28、数组中出现超过一半的数"></a>28、数组中出现超过一半的数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> vote=<span class="number">0</span>,major;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vote==<span class="number">0</span>) major=c;</span><br><span class="line">            vote+= major==c ? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(major==c) sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum&gt;nums.<span class="built_in">size</span>()/<span class="number">2</span> ? major:<span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="29、最小的K个数"><a href="#29、最小的K个数" class="headerlink" title="29、最小的K个数"></a>29、最小的K个数</h4><p>思路：堆排序   || 快排</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; small;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;input.<span class="built_in">size</span>()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:input) small.push(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            res.push_back(small.top());</span><br><span class="line">            small.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="30、连续子数组最大和"><a href="#30、连续子数组最大和" class="headerlink" title="30、连续子数组最大和"></a>30、连续子数组最大和</h4><p>思路：顺序遍历数组，记录begin到目前sum，sum小于0更新begin；max比较各个数值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">array</span>.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">array</span>[i]+=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">array</span>[i<span class="number">-1</span>]);</span><br><span class="line">            res=<span class="built_in">max</span>(res,<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="31、整数中1出现的次数"><a href="#31、整数中1出现的次数" class="headerlink" title="31、整数中1出现的次数"></a>31、整数中1出现的次数</h4><p>思路：  <img src= "/img/loading.gif" data-src="C:%5CUsers%5C%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E9%95%BF%E7%9A%84%E6%B2%B3%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620130720289.png" alt="image-20200620130720289"></p><p>按照 cur 的值来判断不同的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit=<span class="number">1</span>,high=n/<span class="number">10</span>,cur=n%<span class="number">10</span>,low=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(high!=<span class="number">0</span> || cur!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>) res+=high*digit;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>) res+=high*digit+low+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res+=(high+<span class="number">1</span>)*digit;</span><br><span class="line">            low+=cur*digit;</span><br><span class="line">            cur=high%<span class="number">10</span>;</span><br><span class="line">            digit*=<span class="number">10</span>;</span><br><span class="line">            high/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="32-把数组排成最小数"><a href="#32-把数组排成最小数" class="headerlink" title="32.把数组排成最小数"></a>32.把数组排成最小数</h4><p>思路： 利用string的字典排序特性   x+y &lt; y+x</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">com</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b &lt; b+a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:numbers) temp.push_back(to_string(c));</span><br><span class="line">        sort(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>(),com);</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:temp) res+=c;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="34、第一个只出现一次的字符位置"><a href="#34、第一个只出现一次的字符位置" class="headerlink" title="34、第一个只出现一次的字符位置"></a>34、第一个只出现一次的字符位置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:str)&#123;</span><br><span class="line">            mp[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(mp[str[i]]==<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="36、两个链表的第一个公共节点"><a href="#36、两个链表的第一个公共节点" class="headerlink" title="36、两个链表的第一个公共节点"></a>36、两个链表的第一个公共节点</h4><p>​        思路：遍历链表，遇到空去遍历下一个链表，因为两个链表相加长度固定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode* c1=pHead1,*c2=pHead2;</span><br><span class="line">        <span class="keyword">while</span>(c1!=c2)&#123;</span><br><span class="line">            c1= c1==<span class="literal">NULL</span> ? pHead2:c1-&gt;next;</span><br><span class="line">            c2= c2==<span class="literal">NULL</span> ? pHead1:c2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="37、数字在排序数组中出现的次数"><a href="#37、数字在排序数组中出现的次数" class="headerlink" title="37、数字在排序数组中出现的次数"></a>37、数字在排序数组中出现的次数</h4><p>思路：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=data.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right &amp;&amp; data[left] &lt;k) left++;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right &amp;&amp; data[right] &gt;k) right--;</span><br><span class="line">        <span class="keyword">return</span> right-left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="39、平衡二叉树"><a href="#39、平衡二叉树" class="headerlink" title="39、平衡二叉树"></a>39、平衡二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(Tree_deep(root-&gt;left)-Tree_deep(root-&gt;right)) &lt;=<span class="number">1</span> &amp;&amp; IsBalanced_Solution(root-&gt;left) &amp;&amp;IsBalanced_Solution(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Tree_deep</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(Tree_deep(root-&gt;right),Tree_deep(root-&gt;left))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="40、数组中出现一次的数字"><a href="#40、数组中出现一次的数字" class="headerlink" title="40、数组中出现一次的数字"></a>40、数组中出现一次的数字</h4><p>思路：相同的异或为0，data全部异或为  x^y  必有一位为 1 比较data中每个元素该位是不是1然后分开异或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> resEOR=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:data) resEOR^=d;</span><br><span class="line">        <span class="keyword">int</span> first_dif_one=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(((resEOR &amp; <span class="number">1</span>) == <span class="number">0</span>) &amp;&amp; (first_dif_one &lt; <span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)))&#123;</span><br><span class="line">            first_dif_one++;</span><br><span class="line">            resEOR&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *num1=<span class="number">0</span>;*num2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:data)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((c&gt;&gt;first_dif_one) &amp; <span class="number">1</span>)==<span class="number">1</span>) *num1^=c;</span><br><span class="line">            <span class="keyword">else</span> *num2^=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="41、把数组排成最小的数"><a href="#41、把数组排成最小的数" class="headerlink" title="41、把数组排成最小的数"></a>41、把数组排成最小的数</h4><p>思路：s和 =   （l+r) * (r-l+1)/2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">FindContinuousSequence</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>;l &lt; r ;)&#123;</span><br><span class="line">            <span class="keyword">int</span> s=(l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(s==sum)&#123;</span><br><span class="line">                res.push_back(&#123;&#125;);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> w=l;w&lt;=r;w++) res.back().push_back(w);</span><br><span class="line">                l++;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( s &gt; sum) l++;</span><br><span class="line">            <span class="keyword">else</span> r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="42、和为S的两个数字"><a href="#42、和为S的两个数字" class="headerlink" title="42、和为S的两个数字"></a>42、和为S的两个数字</h4><p>思路：双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="built_in">array</span>.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(<span class="number">1</span>);</span><br><span class="line">        res.push_back(INT_MAX);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[l]+<span class="built_in">array</span>[r] &gt; sum) r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[l]+<span class="built_in">array</span>[r] &lt; sum) l++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">array</span>[l]*<span class="built_in">array</span>[r] &lt; res[<span class="number">0</span>]*res[<span class="number">1</span>])&#123;</span><br><span class="line">                    res[<span class="number">0</span>]=<span class="built_in">min</span>(<span class="built_in">array</span>[l],<span class="built_in">array</span>[r]);</span><br><span class="line">                    res[<span class="number">1</span>]=<span class="built_in">max</span>(<span class="built_in">array</span>[l],<span class="built_in">array</span>[r]);</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ress;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">1</span>]==INT_MAX ? ress:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="43、左旋转字符串"><a href="#43、左旋转字符串" class="headerlink" title="43、左旋转字符串"></a>43、左旋转字符串</h4><p>思路：两个相同串相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//case 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(s+s).substr(n,s.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//case 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;n+s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res+=s[i%s.<span class="built_in">size</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="44、翻转单词顺序列"><a href="#44、翻转单词顺序列" class="headerlink" title="44、翻转单词顺序列"></a>44、翻转单词顺序列</h4><p>思路: 翻转 再 翻转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> <span class="built_in">size</span> = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> mark=<span class="number">0</span>;</span><br><span class="line">        str += <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>+<span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                ReverseWord(str, mark, i<span class="number">-1</span>);</span><br><span class="line">                mark = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str = str.substr(<span class="number">0</span>, <span class="built_in">size</span>);</span><br><span class="line">        ReverseWord(str, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReverseWord</span> <span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            swap(str[l], str[r]);</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="45、扑克牌顺子"><a href="#45、扑克牌顺子" class="headerlink" title="45、扑克牌顺子"></a>45、扑克牌顺子</h4><p>思路：记录最大最小值   差小于5  则必定为顺子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums )</span> </span>&#123;</span><br><span class="line">       <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> big=<span class="number">-1</span>,small=<span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">             big=<span class="built_in">max</span>(big,c);</span><br><span class="line">            small=<span class="built_in">min</span>(small,c);</span><br><span class="line">            <span class="keyword">if</span>(st.count(c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            st.insert(c);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>()==<span class="number">0</span> ? <span class="literal">false</span>:big-small &lt;<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="46、约瑟夫环问题"><a href="#46、约瑟夫环问题" class="headerlink" title="46、约瑟夫环问题"></a>46、约瑟夫环问题</h4><p>思路： f(n,m)=(fn-1,m)+m)%n; f(n,m)是n阶段m厄运约瑟夫环问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">             res=(res+m)%i;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="47、求1-n的和-不使用乘除法"><a href="#47、求1-n的和-不使用乘除法" class="headerlink" title="47、求1~n的和  不使用乘除法"></a>47、求1~n的和  不使用乘除法</h4><p>思路：使用 &amp;&amp; || 的短路方式进行递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n&amp;&amp;(n+=Sum_Solution(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="49、把字符串转换成整数"><a href="#49、把字符串转换成整数" class="headerlink" title="49、把字符串转换成整数"></a>49、把字符串转换成整数</h4><p>思路：遍历计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>  sign_num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:str)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'+'</span> &amp;&amp; sign_num==<span class="number">0</span>)&#123;</span><br><span class="line">                sign=<span class="number">1</span>;</span><br><span class="line">                sign_num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'-'</span> &amp;&amp; sign_num==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sign=<span class="number">-1</span>;</span><br><span class="line">                sign_num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                res=res*<span class="number">10</span>+(c-<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="50、数组中重复的数字"><a href="#50、数组中重复的数字" class="headerlink" title="50、数组中重复的数字"></a>50、数组中重复的数字</h4><p>思路：将数组中数字变负数，遇到负数则直接返回</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> cut=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==<span class="number">0</span>) cut++;</span><br><span class="line">            <span class="keyword">if</span>(numbers[<span class="built_in">abs</span>(numbers[i])]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication=<span class="built_in">abs</span>(numbers[i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> numbers[<span class="built_in">abs</span>(numbers[i])]*=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cut&lt;<span class="number">2</span> ? <span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="52、正则表达式"><a href="#52、正则表达式" class="headerlink" title="52、正则表达式"></a>52、正则表达式</h4><p>思路：从后向前遍历，dp规划</p><p><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">int</span> m=<span class="built_in">strlen</span>(pattern);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m+<span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]= i==<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(pattern[j<span class="number">-1</span>] !=<span class="string">'*'</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; (pattern[j<span class="number">-1</span>] == str[i<span class="number">-1</span>] || pattern[j<span class="number">-1</span>] == <span class="string">'.'</span>))&#123;</span><br><span class="line">                            dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j&gt;=<span class="number">2</span>) dp[i][j]=dp[i][j] | dp[i][j<span class="number">-2</span>];</span><br><span class="line">                   </span><br><span class="line">                        <span class="keyword">if</span>( i&gt;=<span class="number">1</span> &amp;&amp; j&gt;=<span class="number">2</span> &amp;&amp; (pattern[j<span class="number">-2</span>] == str[i<span class="number">-1</span>] || pattern[j<span class="number">-2</span>] == <span class="string">'.'</span>) )&#123;</span><br><span class="line">                              dp[i][j]= dp[i][j]|dp[i<span class="number">-1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="53、表示数值的字符串"><a href="#53、表示数值的字符串" class="headerlink" title="53、表示数值的字符串"></a>53、表示数值的字符串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">string</span>==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(*<span class="built_in">string</span>==<span class="string">'+'</span>||*<span class="built_in">string</span>==<span class="string">'-'</span>)</span><br><span class="line">            <span class="built_in">string</span>++;</span><br><span class="line">        <span class="keyword">if</span>(*<span class="built_in">string</span>==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> dot=<span class="number">0</span>,num=<span class="number">0</span>,nume=<span class="number">0</span>;<span class="comment">//分别用来标记小数点、整数部分和e指数是否存在</span></span><br><span class="line">        <span class="keyword">while</span>(*<span class="built_in">string</span>!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*<span class="built_in">string</span>&gt;=<span class="string">'0'</span>&amp;&amp;*<span class="built_in">string</span>&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="built_in">string</span>++;</span><br><span class="line">                num=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(*<span class="built_in">string</span>==<span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dot&gt;<span class="number">0</span>||nume&gt;<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">string</span>++;</span><br><span class="line">                dot=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(*<span class="built_in">string</span>==<span class="string">'e'</span>||*<span class="built_in">string</span>==<span class="string">'E'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span>(num==<span class="number">0</span>||nume&gt;<span class="number">0</span>)</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                  <span class="built_in">string</span>++;</span><br><span class="line">                  nume++;</span><br><span class="line">                  <span class="keyword">if</span>(*<span class="built_in">string</span>==<span class="string">'+'</span>||*<span class="built_in">string</span>==<span class="string">'-'</span>)</span><br><span class="line">                      <span class="built_in">string</span>++;</span><br><span class="line">                 <span class="keyword">if</span>(*<span class="built_in">string</span>==<span class="string">'\0'</span>)</span><br><span class="line">                     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="54、字符流中第一个不重复的字符"><a href="#54、字符流中第一个不重复的字符" class="headerlink" title="54、字符流中第一个不重复的字符"></a>54、字符流中第一个不重复的字符</h4><p>思路：使用map记录次数，次数为1时进queue；取值时去queue中第一个值为1的char</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; dq;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         mp[ch]++;</span><br><span class="line">        <span class="keyword">if</span>(mp[ch]==<span class="number">1</span>) dq.push(ch);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty() &amp;&amp; mp[dq.front()] &gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            dq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dq.empty()) <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> dq.front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="55、链表中环的入口节点"><a href="#55、链表中环的入口节点" class="headerlink" title="55、链表中环的入口节点"></a>55、链表中环的入口节点</h4><p>思路：<img src= "/img/loading.gif" data-src="C:%5CUsers%5C%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E9%95%BF%E7%9A%84%E6%B2%B3%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200619140533304.png" alt="image-20200619140533304"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> walker = head;</span><br><span class="line">        <span class="keyword">auto</span> runner = head;</span><br><span class="line">        <span class="keyword">while</span>(runner &amp;&amp; runner-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">            runner = runner-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(walker == runner)</span><br><span class="line">            &#123;</span><br><span class="line">                walker=head;</span><br><span class="line">                <span class="keyword">while</span>(walker!=runner)&#123;</span><br><span class="line">                    walker=walker-&gt;next;</span><br><span class="line">                    runner=runner-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> runner;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="56、删除链表中重复的节点"><a href="#56、删除链表中重复的节点" class="headerlink" title="56、删除链表中重复的节点"></a>56、删除链表中重复的节点</h4><p>思路：前后指针，记录最后一个重复的节点，跳过即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!pHead || !pHead-&gt;next) <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode* res=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        res-&gt;next=pHead;</span><br><span class="line">        ListNode* pre=res,*last=res-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(last)&#123;</span><br><span class="line">             <span class="keyword">if</span>(last-&gt;next &amp;&amp; last-&gt;val==last-&gt;next-&gt;val)&#123;</span><br><span class="line">                   <span class="keyword">while</span>(last-&gt;next &amp;&amp; last-&gt;val==last-&gt;next-&gt;val) last=last-&gt;next;</span><br><span class="line">                   pre-&gt;next=last-&gt;next;</span><br><span class="line">                   last=last-&gt;next;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre=pre-&gt;next;</span><br><span class="line">                last=last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="57、二叉树的下一节点"><a href="#57、二叉树的下一节点" class="headerlink" title="57、二叉树的下一节点"></a>57、二叉树的下一节点</h4><p>思路：观察中序遍历节点顺序    当前节点下一数字  1：存在右子树则为右子树的最左节点   2.有父节点 且父节点左子节点不为当前节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//返回当前节点的下一节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//先找右子树的最左节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;right)&#123;</span><br><span class="line">           pNode=pNode-&gt;right;</span><br><span class="line">           <span class="keyword">while</span>(pNode-&gt;left) pNode=pNode-&gt;left;</span><br><span class="line">           <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;next-&gt;left==pNode) <span class="keyword">return</span> pNode-&gt;next;</span><br><span class="line">            pNode=pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="58、对称的二叉树"><a href="#58、对称的二叉树" class="headerlink" title="58、对称的二叉树"></a>58、对称的二叉树</h4><p>递归： 中序遍历  比左右  比右左</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> mid(pRoot-&gt;left,pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">mid</span><span class="params">(TreeNode *l,TreeNode *r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="literal">NULL</span>) <span class="keyword">return</span> r==<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(r==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;val == r-&gt;val)&#123;</span><br><span class="line">          <span class="keyword">return</span> mid(l-&gt;left,r-&gt;right) &amp;&amp; mid(l-&gt;right,r-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代：DFS</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(pRoot-&gt;left);</span><br><span class="line">        st.push(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            TreeNode* f=st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            TreeNode* r=st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>( !f &amp;&amp; !r ) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">if</span>( !f || !r ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(f-&gt;val != r-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            st.push(f-&gt;left);st.push(r-&gt;right);</span><br><span class="line">            st.push(f-&gt;right);st.push(r-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    BFS 与深搜一模一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(pRoot-&gt;left);</span><br><span class="line">        st.push(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            TreeNode* f=st.front();</span><br><span class="line">            st.pop();</span><br><span class="line">            TreeNode* r=st.front();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>( !f &amp;&amp; !r ) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">if</span>( !f || !r ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(f-&gt;val != r-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            st.push(f-&gt;left);st.push(r-&gt;right);</span><br><span class="line">            st.push(f-&gt;right);st.push(r-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="59、按之字形顺序打印二叉树"><a href="#59、按之字形顺序打印二叉树" class="headerlink" title="59、按之字形顺序打印二叉树"></a>59、按之字形顺序打印二叉树</h4><p>思路：es.back().insert(res.back().begin(),temp-&gt;val); 使用插入函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">Print</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> res;</span><br><span class="line">        qu.push(pRoot);</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len=qu.<span class="built_in">size</span>();</span><br><span class="line">            flag=!flag;</span><br><span class="line">            res.push_back(&#123;&#125;);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode* temp=qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                <span class="keyword">if</span>(flag) res.back().push_back(temp-&gt;val);</span><br><span class="line">                <span class="keyword">else</span> res.back().insert(res.back().<span class="built_in">begin</span>(),temp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left) qu.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right) qu.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="60、把二叉树打印成多行"><a href="#60、把二叉树打印成多行" class="headerlink" title="60、把二叉树打印成多行"></a>60、把二叉树打印成多行</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">Print</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">            <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class="line">            qu.push(pRoot);</span><br><span class="line">            <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> len=qu.<span class="built_in">size</span>();</span><br><span class="line">                res.push_back(&#123;&#125;);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* temp=qu.front();</span><br><span class="line">                    qu.pop();</span><br><span class="line">                    res.back().push_back(temp-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(temp-&gt;left) qu.push(temp-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(temp-&gt;right) qu.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="61、序列号二叉树"><a href="#61、序列号二叉树" class="headerlink" title="61、序列号二叉树"></a>61、序列号二叉树</h4><p>思路：沙雕思路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;    </span><br><span class="line">        r=root;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Solution"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="62、二叉搜索树的第K个节点"><a href="#62、二叉搜索树的第K个节点" class="headerlink" title="62、二叉搜索树的第K个节点"></a>62、二叉搜索树的第K个节点</h4><p>思路：中序遍历计数即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mid_ord</span><span class="params">(TreeNode* root,TreeNode* &amp;ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root &amp;&amp; !ans)&#123;</span><br><span class="line">             mid_ord(root-&gt;left,ans);</span><br><span class="line">             count--;</span><br><span class="line">             <span class="keyword">if</span>(count==<span class="number">0</span>) ans=root;</span><br><span class="line">             mid_ord(root-&gt;right,ans);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        TreeNode* ans=<span class="literal">NULL</span>;</span><br><span class="line">        count=k;</span><br><span class="line">        mid_ord(pRoot,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="63、数据流中的中位数"><a href="#63、数据流中的中位数" class="headerlink" title="63、数据流中的中位数"></a>63、数据流中的中位数</h4><p>思路：使用两个优先队列   priority_queue&lt;a,b,c&gt;  b是vector或deque    c=less </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; big;<span class="comment">//大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; small;<span class="comment">//小顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        small.push(num); big.push(small.top());small.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(big.<span class="built_in">size</span>() &gt; small.<span class="built_in">size</span>())&#123;</span><br><span class="line">            small.push(big.top());</span><br><span class="line">            big.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  small.<span class="built_in">size</span>() &gt; big.<span class="built_in">size</span>() ? <span class="number">1.0</span>*small.top():<span class="number">0.5</span>*(small.top()+big.top());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进阶：1。如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？</p><p>不用建堆了，用一个int[101] arr记录某个数据出现的次数。要取中位数时，第一次遍历数组累加得出总个数。然后除以2得出要找的数的位置p并知道是奇数还是偶数，然后第二次遍历数组，p-=arr[i]，当p变为1和0时分别记下i、j。奇数个数则返回j，偶数个数则返回(i+j)/2。</p><p>2。如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</p><p>同样参照1的思路，用int[102] arr记录数据出现的次数，arr[101]记录大于100的数的次数。由于数据主要分布在100及以内，可知中间的2个数还是在100或以内，1的算法仍然有效。</p><h4 id="64、滑动窗口最大值"><a href="#64、滑动窗口最大值" class="headerlink" title="64、滑动窗口最大值"></a>64、滑动窗口最大值</h4><p>思路：使用双端队列，记录截止当前的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len=num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span> &gt; len || <span class="built_in">size</span> &lt; <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(dq.<span class="built_in">size</span>() &amp;&amp; num[dq.back()] &lt;= num[i]) dq.pop_back();</span><br><span class="line">            <span class="keyword">while</span>(dq.<span class="built_in">size</span>() &amp;&amp; (i-dq.front()+<span class="number">1</span> &gt; <span class="built_in">size</span> )) dq.pop_front();</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">size</span> &amp;&amp; (i+<span class="number">1</span>)&gt;=<span class="built_in">size</span>) res.push_back(num[dq.front()]);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="65、矩阵中的路径"><a href="#65、矩阵中的路径" class="headerlink" title="65、矩阵中的路径"></a>65、矩阵中的路径</h4><p>思路：dfs遍历完事</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mstr=str;</span><br><span class="line">        mr=rows;</span><br><span class="line">        mc=cols;</span><br><span class="line">        len=<span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">if</span>(!len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(rows==<span class="number">0</span> || cols==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(matrix,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>* matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=mr || j&lt;<span class="number">0</span> || j&gt;=mc || matrix[i*mc+j]!=mstr[index]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(index == len<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">char</span> temp=mstr[index];</span><br><span class="line">        matrix[i*mc+j]=<span class="string">'&amp;'</span>;</span><br><span class="line">        <span class="keyword">bool</span> res=dfs(matrix,i<span class="number">-1</span>,j,index+<span class="number">1</span>) || dfs(matrix,i,j<span class="number">-1</span>,index+<span class="number">1</span>) || dfs(matrix,i+<span class="number">1</span>,j,index+<span class="number">1</span>) || \</span><br><span class="line">            dfs(matrix,i,j+<span class="number">1</span>,index+<span class="number">1</span>);</span><br><span class="line">        matrix[i*mc+j]=temp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> len,mr,mc;</span><br><span class="line">        <span class="keyword">char</span>* mstr;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="66、机器人运动范围"><a href="#66、机器人运动范围" class="headerlink" title="66、机器人运动范围"></a>66、机器人运动范围</h4><p>思路：记录上左能否到达，然后判断当前是否是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x /= <span class="number">10</span>)&#123;</span><br><span class="line">            res += x % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">vis</span><span class="params">(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols,<span class="number">0</span>))</span></span>;</span><br><span class="line">        vis[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( (i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) ||<span class="built_in">get</span>(i)+<span class="built_in">get</span>(j) &gt; k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>) vis[i][j]|=vis[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>) vis[i][j]|=vis[i][j<span class="number">-1</span>];</span><br><span class="line">                res+=vis[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="67、剪绳子"><a href="#67、剪绳子" class="headerlink" title="67、剪绳子"></a>67、剪绳子</h4><p>思路：1.切的越多乘积越大 2.每段为3最佳</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">int</span> a=n/<span class="number">3</span>,b=n%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>,a);</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>,a<span class="number">-1</span>)*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>,a)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;牛客网剑指Offer&quot;&gt;&lt;a href=&quot;#牛客网剑指Offer&quot; class=&quot;headerlink&quot; title=&quot;牛客网剑指Offer&quot;&gt;&lt;/a&gt;牛客网剑指Offer&lt;/h1&gt;&lt;p&gt;面试51&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;p&gt;leetcode 滑动数组中的中
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++内存管理</title>
    <link href="https://yangchandler.github.io/2020/07/21/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://yangchandler.github.io/2020/07/21/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-07-21T13:04:08.398Z</published>
    <updated>2020-07-20T13:51:27.992Z</updated>
    
    <content type="html"><![CDATA[<p>C++内存管理，分为栈区、堆区、数据区以及代码区。</p><p>以下内容多源自网络，部分内容进行过验证，不确保所有都正确。</p><h3 id="1、栈"><a href="#1、栈" class="headerlink" title="1、栈"></a>1、栈</h3><p>​        栈又称运行时栈，是OS层面的结构。在运行函数时，函数内局部变量的存储单元在栈上创建，函数执行结束时这些存储单元自动释放。栈内存分配是处理器内置函数，效率很高。栈的存储空间是连续的，VC++默认大小为1MB，其增长方式为高地址到低地址。需要注意的是并非所有局部变量都会在栈上申请空间，当寄存器大小不够时、当局部变量使用地址运算符 ‘&amp;’时，当局部变量是数组或者结构时。 当调用函数参数大于6时，多出6的参数部分也会在栈上产生一个临时空间，原因是调用函数最多可以使用6个寄存器，及传递一次6个参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在g++编译时可以通过如下命令修改运行栈大小  size为字节数</span></span><br><span class="line">g++ main.cpp -o main -g -Wl,-<span class="built_in">stack</span>=<span class="built_in">size</span></span><br></pre></td></tr></table></figure><h3 id="2、堆"><a href="#2、堆" class="headerlink" title="2、堆"></a>2、堆</h3><p>​        堆是OS层面结构，由程序员创建与维护，new/malloc 对应于 delete/free ，若创建后不销毁，程序结束时由O自动收回。C++标准中将new/delete分配和释放的内存区域称为自由存储区，但由于其是通过malloc/free来实现的，所以可以将自由存储区理解为堆的一个子集(或者理解为语言层面的抽象定义)。</p><p>​    操作系统可能会使用“虚存”的概念，在内存耗尽时直接把硬盘当作内存来使用。</p><p>​                                                                         <strong>new 与 malloc的区别</strong></p><table><thead><tr><th align="center">不同点</th><th align="center">new</th><th align="center">malloc</th></tr></thead><tbody><tr><td align="center">属性</td><td align="center">C++关键字</td><td align="center">库函数</td></tr><tr><td align="center">参数</td><td align="center">无需指出内存大小</td><td align="center">需要参数显示指出申请内存大小</td></tr><tr><td align="center">返回类型</td><td align="center">与对象类型指针相同/抛出异常</td><td align="center">void*/NULL</td></tr><tr><td align="center">调用构造和析构函数</td><td align="center">调用 operator new函数 ；<br />执行构造函数；</td><td align="center">申请空间</td></tr></tbody></table><h3 id="3、数据区"><a href="#3、数据区" class="headerlink" title="3、数据区"></a>3、数据区</h3><p>​    存放全局变量、静态变量。初始化的全局变量和静态变量放在一起，未初始化或者初始化为0的全局变量和静态变量放在一起。其是直接从可执行文件复制而来，在运行时为其分配内存。</p><p>​    这块内存在程序整个运行期都存在。</p><h3 id="4、代码区"><a href="#4、代码区" class="headerlink" title="4、代码区"></a>4、代码区</h3><h4 id="4-1常量区（代码区的只读存储区）"><a href="#4-1常量区（代码区的只读存储区）" class="headerlink" title="4.1常量区（代码区的只读存储区）"></a>4.1常量区（代码区的只读存储区）</h4><p>​        存放常量（字符串常量），不允许修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">char</span> *p=<span class="string">"12345"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,p);   <span class="comment">//0X00409001     字符串存在于常量区，p存在于栈</span></span><br><span class="line"><span class="keyword">char</span> *q=<span class="string">"12345"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,q);<span class="comment">//0X00409001 同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">10</span>;     <span class="comment">//                10存在于代码区 ？ (汇编中有立即数传给M的指令)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;a);  <span class="comment">//0X61FE08        const int a 是局部变量，存在于栈区 </span></span><br><span class="line">    <span class="comment">// const 变量（对象）只有在使用时才会对其分配内存，否则就是将其映射到符号表中</span></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;x);  <span class="comment">//0X61FE04</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> pp[]=<span class="string">"12345"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,pp);  <span class="comment">//0X61FE00     pp在栈上，“12345”也从常量区复制到栈上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2、代码区（代码区的文本区）"><a href="#4-2、代码区（代码区的文本区）" class="headerlink" title="4.2、代码区（代码区的文本区）"></a>4.2、代码区（代码区的文本区）</h4><p>​            存放程序的代码，性质为只读。代码段总是从0x0040000开始</p><h3 id="6、栈和堆的区别"><a href="#6、栈和堆的区别" class="headerlink" title="6、栈和堆的区别"></a>6、栈和堆的区别</h3><p>​    管理方式：栈由编译器或者OS自动控制；堆由程序员控制</p><p>​    空间大小：以32位系统为例，栈大小为1M（可改），堆大小可为4G</p><p>​    碎片问题：堆可能会产生很多内存碎片，而栈不会</p><p>​    分配方式： 栈可以静态分配（局部变量）以及动态分配（alloc），堆都是动态分配的</p><p>​    分配效率：栈的效率要高于堆，因为栈是OS层面的结构，CPU会为栈提供支持；堆是由库函数提供的，机制较为复杂，寻址判断等导致效率较低</p><h3 id="7、链接与装载"><a href="#7、链接与装载" class="headerlink" title="7、链接与装载"></a>7、链接与装载</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++内存管理，分为栈区、堆区、数据区以及代码区。&lt;/p&gt;
&lt;p&gt;以下内容多源自网络，部分内容进行过验证，不确保所有都正确。&lt;/p&gt;
&lt;h3 id=&quot;1、栈&quot;&gt;&lt;a href=&quot;#1、栈&quot; class=&quot;headerlink&quot; title=&quot;1、栈&quot;&gt;&lt;/a&gt;1、栈&lt;/h3
      
    
    </summary>
    
    
      <category term="C++" scheme="https://yangchandler.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yangchandler.github.io/2020/07/21/hello-world/"/>
    <id>https://yangchandler.github.io/2020/07/21/hello-world/</id>
    <published>2020-07-21T13:00:18.948Z</published>
    <updated>2020-07-21T13:00:18.948Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
